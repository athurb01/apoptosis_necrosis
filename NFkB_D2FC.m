
classdef NFkB_D2FC
    % 
    % A class implementing the ordinary differential equations
    % for the NFkB_D2FC model.
    %
    % Save as NFkB_D2FC.m.
    %
    % Generated by pysb.export.matlab.MatlabExporter.
    %
    % Properties
    % ----------
    % observables : struct
    %     A struct containing the names of the observables from the
    %     PySB model as field names. Each field in the struct
    %     maps the observable name to a matrix with two rows:
    %     the first row specifies the indices of the species
    %     associated with the observable, and the second row
    %     specifies the coefficients associated with the species.
    %     For any given timecourse of model species resulting from
    %     integration, the timecourse for an observable can be
    %     retrieved using the get_observable method, described
    %     below.
    %
    % parameters : struct
    %     A struct containing the names of the parameters from the
    %     PySB model as field names. The nominal values are set by
    %     the constructor and their values can be overriden
    %     explicitly once an instance has been created.
    %
    % Methods
    % -------
    % NFkB_D2FC.odes(tspan, y0)
    %     The right-hand side function for the ODEs of the model,
    %     for use with MATLAB ODE solvers (see Examples).
    %
    % NFkB_D2FC.get_initial_values()
    %     Returns a vector of initial values for all species,
    %     specified in the order that they occur in the original
    %     PySB model (i.e., in the order found in model.species).
    %     Non-zero initial conditions are specified using the
    %     named parameters included as properties of the instance.
    %     Hence initial conditions other than the defaults can be
    %     used by assigning a value to the named parameter and then
    %     calling this method. The vector returned by the method
    %     is used for integration by passing it to the MATLAB
    %     solver as the y0 argument.
    %
    % NFkB_D2FC.get_observables(y)
    %     Given a matrix of timecourses for all model species
    %     (i.e., resulting from an integration of the model),
    %     get the trajectories corresponding to the observables.
    %     Timecourses are returned as a struct which can be
    %     indexed by observable name.
    %
    % Examples
    % --------
    % Example integration using default initial and parameter
    % values:
    %
    % >> m = NFkB_D2FC();
    % >> tspan = [0 100];
    % >> [t y] = ode15s(@m.odes, tspan, m.get_initial_values());
    %
    % Retrieving the observables:
    %
    % >> y_obs = m.get_observables(y)
    %
    properties
        observables
        parameters
    end

    methods
        function self = NFkB_D2FC()
            % Assign default parameter values
            self.parameters = struct( ...
                'cell_vol', 2.6999999999999998e-12, ...
                'nuc_vol', 6.2790697674418602e-13, ...
                'cyt_vol', 2.0720930232558138e-12, ...
                'cellmem_vol', 9.3753299083903215e-15, ...
                'nucmem_vol', 3.5454735952377009e-15, ...
                'IkBaNFkB_0', 374353, ...
                'neut_IKK_0', 100000, ...
                'act_IKK_0', 0, ...
                'inact_IKK_0', 0, ...
                'kact_IKK', 0, ...
                'kinact_IKK', 0.0030000000000000001, ...
                'kneut_IKK', 0.00059999999999999995, ...
                'kbind_IkBa_NF', 8.3027000000000003e-19, ...
                'kdis_IkBa_NF', 0.050000000000000003, ...
                'kphos_IkBa', 1.2288e-19, ...
                'kphos_IkBaNF', 6.1439999999999998e-19, ...
                'kdeg_pIkBa', 0.10000000000000001, ...
                'kimp_NFkB', 0.0025999999999999999, ...
                'kexp_NFkB', 0.00017159999999999997, ...
                'kexp_IkBaNF', 0.033000000000000002, ...
                'kimp_IkBa', 0.00067000000000000002, ...
                'kexp_IkBa', 0.0011054999999999999, ...
                'ksynth_IkBa', 0.5, ...
                'kdeg_tIkBa', 0.00029999999999999997, ...
                'kdeg_IkBa', 0.00050000000000000001, ...
                'kdeg_bIkBa', 2.1999999999999999e-05, ...
                'ksynth_A20', 0.5, ...
                'kdeg_tA20', 0.00040000000000000002, ...
                'kdeg_A20', 0.0044999999999999997, ...
                'kdeg_tTarget', 0.00040000000000000002, ...
                'ksynth_Comp', 0.5, ...
                'kdeg_tComp', 4.0000000000000003e-05, ...
                'kdeg_Comp', 0.00050000000000000001);

            % Define species indices (first row) and coefficients
            % (second row) of named observables
            self.observables = struct( ...
                'o_neut_IKKc', [1; 1], ...
                'o_act_IKKc', [3; 1], ...
                'o_inact_IKKc', [6; 1], ...
                'o_NFkB_cyt', [5; 1], ...
                'o_NFkB_nuc', [9; 1], ...
                'o_IkBa_cyt', [4; 1], ...
                'o_IkBa_nuc', [10; 1], ...
                'o_IkBa_p', [7; 1], ...
                'o_IkBaNFkB_cyt', [2; 1], ...
                'o_IkBaNFkB_nuc', [11; 1], ...
                'o_tIkBa', [12; 1], ...
                'o_tA20', [13; 1], ...
                'o_A20', [16; 1], ...
                'o_tTarget', [14; 1], ...
                'o_tComp', [15; 1], ...
                'o_Comp_nuc', [17; 1]);
        end

        function initial_values = get_initial_values(self)
            % Return the vector of initial conditions for all
            % species based on the values of the parameters
            % as currently defined in the instance.

            initial_values = zeros(1,17);
            initial_values(1) = self.parameters.neut_IKK_0; % IKK(b=None, s='n') ** cyt
            initial_values(2) = self.parameters.IkBaNFkB_0; % (IkBa(b=1, s='u') % NFkB(b=1)) ** cyt
        end

        function y = odes(self, tspan, y0)
            % Right hand side function for the ODEs

            % Shorthand for the struct of model parameters
            p = self.parameters;

            % IKK(b=None, s='n') ** cyt;
            y(1,1) = y0(6)*p.kneut_IKK + (y0(1)*p.kact_IKK)*(-1);
            % IkBa(b=1, s='u') ** cyt % NFkB(b=1) ** cyt;
            y(2,1) = y0(11)*p.kexp_IkBaNF + 482603820000.0*y0(4)*y0(5)*p.kbind_IkBa_NF + (y0(2)*p.kdeg_bIkBa)*(-1) + (y0(2)*p.kdis_IkBa_NF)*(-1) + (482603820000.0*y0(2)*y0(3)*p.kphos_IkBaNF)*(-1);
            % IKK(b=None, s='a') ** cyt;
            y(3,1) = y0(1)*p.kact_IKK + (y0(3)*p.kinact_IKK)*(-1);
            % IkBa(b=None, s='u') ** cyt;
            y(4,1) = y0(2)*p.kdis_IkBa_NF + y0(12)*p.ksynth_IkBa + y0(10)*p.kexp_IkBa + (y0(4)*p.kdeg_IkBa)*(-1) + (y0(4)*p.kimp_IkBa)*(-1) + (482603820000.0*y0(3)*y0(4)*p.kphos_IkBa)*(-1) + (482603820000.0*y0(4)*y0(5)*p.kbind_IkBa_NF)*(-1);
            % NFkB(b=None) ** cyt;
            y(5,1) = y0(2)*p.kdeg_bIkBa + y0(2)*p.kdis_IkBa_NF + y0(8)*p.kdeg_pIkBa + y0(9)*p.kexp_NFkB + (y0(5)*p.kimp_NFkB)*(-1) + (482603820000.0*y0(4)*y0(5)*p.kbind_IkBa_NF)*(-1);
            % IKK(b=None, s='i') ** cyt;
            y(6,1) = y0(3)*p.kinact_IKK + (y0(6)*p.kneut_IKK)*(-1);
            % IkBa(b=None, s='p') ** cyt;
            y(7,1) = 482603820000.0*y0(3)*y0(4)*p.kphos_IkBa + (y0(7)*p.kdeg_pIkBa)*(-1);
            % IkBa(b=1, s='p') ** cyt % NFkB(b=1) ** cyt;
            y(8,1) = 482603820000.0*y0(2)*y0(3)*p.kphos_IkBaNF + (y0(8)*p.kdeg_pIkBa)*(-1);
            % NFkB(b=None) ** nuc;
            y(9,1) = y0(11)*p.kdis_IkBa_NF + y0(5)*p.kimp_NFkB + (y0(9)*p.kexp_NFkB)*(-1) + (1592592500000.0*y0(9)*y0(10)*p.kbind_IkBa_NF)*(-1);
            % IkBa(b=None, s='u') ** nuc;
            y(10,1) = y0(11)*p.kdis_IkBa_NF + y0(4)*p.kimp_IkBa + (y0(10)*p.kdeg_IkBa)*(-1) + (y0(10)*p.kexp_IkBa)*(-1) + (1592592500000.0*y0(9)*y0(10)*p.kbind_IkBa_NF)*(-1);
            % IkBa(b=1, s='u') ** nuc % NFkB(b=1) ** nuc;
            y(11,1) = 1592592500000.0*y0(9)*y0(10)*p.kbind_IkBa_NF + (y0(11)*p.kdis_IkBa_NF)*(-1) + (y0(11)*p.kexp_IkBaNF)*(-1);
            % tIkBa() ** cyt;
            y(12,1) = y0(9)*ktran_IkBa + (y0(12)*p.kdeg_tIkBa)*(-1);
            % tA20() ** cyt;
            y(13,1) = y0(9)*ktran_A20 + (y0(13)*p.kdeg_tA20)*(-1);
            % tTarget() ** cyt;
            y(14,1) = y0(9)*ktran_Target + (y0(14)*p.kdeg_tTarget)*(-1);
            % tComp() ** nuc;
            y(15,1) = y0(9)*ktran_Comp + (y0(15)*p.kdeg_Comp)*(-1);
            % A20() ** cyt;
            y(16,1) = y0(13)*p.ksynth_A20 + (y0(16)*p.kdeg_A20)*(-1);
            % Comp() ** nuc;
            y(17,1) = y0(15)*p.ksynth_Comp + (y0(17)*p.kdeg_Comp)*(-1);
        end

        function y_obs = get_observables(self, y)
            % Retrieve the trajectories for the model observables
            % from a matrix of the trajectories of all model
            % species.

            % Initialize the struct of observable timecourses
            % that we will return
            y_obs = struct();

            % Iterate over the observables;
            observable_names = fieldnames(self.observables);
            for i = 1:numel(observable_names)
                obs_matrix = self.observables.(observable_names{i});
                if isempty(obs_matrix)
                    y_obs.(observable_names{i}) = zeros(size(y, 1), 1);
                    continue
                end
                species = obs_matrix(1, :);
                coefficients = obs_matrix(2, :);
                y_obs.(observable_names{i}) = ...
                                y(:, species) * coefficients';
            end
        end
    end
end

